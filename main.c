#include <SDL3/SDL.h>
#include <glad/glad.h>
#include <stdio.h>

#define drawOneLine(x1, y1, x2, y2) \
    glBegin(GL_LINES); \
        glVertex2f(x1, y1); \
        glVertex2f(x2, y2); \
    glEnd();

// GLubyte fly[] = {
//     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//     0x03, 0x80, 0x01, 0xC0, 0x06, 0xC0, 0x03, 0x60,
//     0x04, 0x60, 0x06, 0x20, 0x04, 0x30, 0x0C, 0x20,
//     0x04, 0x18, 0x18, 0x20, 0x04, 0x0C, 0x30, 0x20,
//     0x04, 0x06, 0x60, 0x20, 0x44, 0x03, 0xC0, 0x22,
//     0x44, 0x01, 0x80, 0x22, 0x44, 0x01, 0x80, 0x22,
//     0x44, 0x01, 0x80, 0x22, 0x44, 0x01, 0x80, 0x22,
//     0x44, 0x01, 0x80, 0x22, 0x44, 0x01, 0x80, 0x22,
//     0x66, 0x01, 0x80, 0x66, 0x33, 0x01, 0x80, 0xCC,
//     0x19, 0x81, 0x81, 0x98, 0x0C, 0xC1, 0x83, 0x30,
//     0x07, 0xE1, 0x87, 0xE0, 0x03, 0x3F, 0xFC, 0xC0,
//     0x03, 0x31, 0x8C, 0xC0, 0x03, 0x33, 0xCC, 0xC0,
//     0x06, 0x64, 0x26, 0x60, 0x0C, 0xCC, 0x33, 0x30,
//     0x18, 0xCC, 0x33, 0x18, 0x10, 0xC4, 0x23, 0x08,
//     0x10, 0x63, 0xC6, 0x08, 0x10, 0x30, 0x0C, 0x08,
//     0x10, 0x18, 0x18, 0x08, 0x10, 0x00, 0x00, 0x08,
// };

// GLubyte halftone[] = {
//     0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
//     0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
//     0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
//     0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
//     0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
//     0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
//     0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
//     0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
//     0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
//     0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
//     0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
//     0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
//     0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
//     0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
//     0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
//     0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
// };


void reshape(int width, int height) {
    glViewport(0, 0, width, height);
    glLoadIdentity();
    glOrtho(0.0, width, 0.0, height, -1.0, 1.0);
}

int main() {
    if (!SDL_Init(SDL_INIT_VIDEO)) {
        fprintf(stderr, "SDL Init failed: %s\n", SDL_GetError());
        return 1;
    }

    // int w = 96*3, h = 96;
    int w = 800, h = 600;
    SDL_Window* window = SDL_CreateWindow("OpenGL 2.1 + SDL3 (C)",
                                          w, h,
                                          SDL_WINDOW_OPENGL | SDL_WINDOW_RESIZABLE);

    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 2);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 1);

    SDL_GLContext context = SDL_GL_CreateContext(window);
    if (!context) {
        fprintf(stderr, "OpenGL context creation failed: %s\n", SDL_GetError());
        return 1;
    }

    if (!gladLoadGLLoader((GLADloadproc)SDL_GL_GetProcAddress)) {
        fprintf(stderr, "Failed to initialize GLAD\n");
        return 1;
    }

    printf("OpenGL version: %s\n", glGetString(GL_VERSION));

    // Set the initial orthographic projection to match the window size
    reshape(w, h);

    // if (glUniformMatrix4x3fv) {
    //     printf("glUniformMatrix4x3fv is available. OpenGL 2.1 is supported.\n");
    // } else {
    //     printf("glUniformMatrix4x3fv is not available. OpenGL 2.1 is not supported.\n");
    // }

    // if (glSpecializeShader) {
    //     printf("glSpecializeShader is available. OpenGL 4.6 is supported.\n");
    // } else {
    //     printf("glSpecializeShader is not available. OpenGL 4.6 is not supported.\n");
    // }

    int running = 1;
    SDL_Event e;
    while (running) {
        while (SDL_PollEvent(&e)) {
            if (e.type == SDL_EVENT_QUIT) {
                running = 0;
            }
            if (e.type == SDL_EVENT_WINDOW_RESIZED) {
                w = e.window.data1;
                h = e.window.data2;
                reshape(w, h);
            }
            if (e.type == SDL_EVENT_KEY_DOWN) {
                if (e.key.key == SDLK_ESCAPE) {
                    running = 0;
                }
            }
        }
        glClear(GL_COLOR_BUFFER_BIT);
        glColor3f(1.0, 0.0, 0.0);
        
        glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
        glBegin(GL_POLYGON);
            glEdgeFlag(GL_TRUE);
            glVertex2f(100.0, 100.0);
            glEdgeFlag(GL_FALSE);
            glVertex2f(100.0, 200.0);
            glVertex2f(200.0, 200.0);
            glEdgeFlag(GL_TRUE);
            glVertex2f(200.0, 100.0);
        glEnd();

        SDL_GL_SwapWindow(window);
    }

    SDL_GL_DestroyContext(context);
    SDL_DestroyWindow(window);
    SDL_Quit();
    return 0;
}
